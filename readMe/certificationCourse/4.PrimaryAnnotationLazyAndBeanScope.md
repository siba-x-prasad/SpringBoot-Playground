# @Primary Annotation
- Alternate solution to Qualifiers
- Alternate solution
- Instead of specifying a coach by name using @Qualifier
- I simply need a coach ... I don't care which coach
- If there are multiple coaches
- Then you coaches figure it out ... and tell me who's the primary coach

## @Primary - Only one
- When using @Primary, can have only one for multiple implementations
- If you mark multiple classes with @Primary ... umm, we have a problem
- Unsatisfied dependency expressed through constructor parameter 0:
- No qualifying bean of type 'Coach' available: more than one 'primary' bean found among candidates: [baseballCoach, cricketCoach, tennisCoach, trackCoach]
## Mixing Qualifier and Primary
- If you mix @Primary and @qualifier
- @Qualifier have higher priority
- Even if you are using @primary to a class and you are also using Qualifier, then Primary will be overwritten by Qualifier.
## Which one: @Primary or @Qualifier?
- @Primary leaves it up to the implementation classes
- Could have the issue of multiple @Primary classes leading to an error
- @Qualifier allows to you be very specific on which bean you want
- In general, I recommend using @Qualifier
- More specific
- Higher priority
## Lazy Initialization
- Instead of creating all beans up front, we can specify lazy initialization
- A bean will only be initialized in the following cases:
- It is needed for dependency injection
- Or it is explicitly requested
- Add the @Lazy annotation to a given clas
```
@Component
@Lazy
public class TrackCoach implements Coach {
    public TrackCoach() {
        System.out.println("In constructor: " + getClass().getSimpleName());
    }
    @Override
    public String getDailyWorkout() {
        return "Run a hard 5k!";
    }
}
```
### More about lazy initialization
- To configure other beans for lazy initialization 
- We would need to add @Lazy to each class 
- Turns into tedious work for a large number of classes 
- I wish we could set a global configuration property ...

### Lazy Initialization - Global configuration
- File: application.properties
```
spring.main.lazy-initialization=true
```
- Once we access REST endpoint / dailywork
- Spring will determine dependencies for DemoController ...
- All beans are lazy ... no beans are created until needed, Including our DemoController
- For dependency resolution
- Spring creates instance of CricketCoach first ...
- Then creates instance of DemoController and injects the CricketCoach

### Lazy Initialization Advantages and DIsadvantages
- **Advantages**
- Only create objects as needed
- May help with faster startup time if you have large number of components
- **Disadvantages**
- If you have web related components like @RestController, not created until requested
- May not discover configuration issues until too late
- Need to make sure you have enough memory for all beans once created

- Lazy initialization feature is disabled by default.
- You should profile your application before configuring lazy initialization.
- Avoid the common pitfall of premature optimization.

# Bean Scopes
- Scope refers to the lifecycle of a bean.
- How long does the bean live?
- How many instances are created?
- How is the bean shared?
- **Default Scope is Singleton**
## Refresher: What Is a Singleton?
- Spring Container creates only one instance of the bean, by default
- It is cached in memory
- All dependency injections for the bean,
- will reference the SAME bean
### Explicitly Specify Bean Scope
```
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import org springframework. stereotype.Component;

@Component
@Scope (ConfigurableBeanFactory •SCOPE_SINGLETON)
public class CricketCoach implements Coach {
    ...
}
```
## Additional Spring Bean Scopes

| Scope       | Description                                                 | Annotation                                          |
|-------------|-------------------------------------------------------------|-----------------------------------------------------|
| singleton   | Create a single shared instance of the bean. Default scope. | ConfigurableBeanFactory.SCOPE_SINGLETON             |
| prototype   | Creates a new bean instance for each container request.     | ConfigurableBeanFactory.SCOPE_PROTOTYPE             |
| request     | Scoped to an HTTP web request. Only used for web apps.      | @Scope(value = WebApplicationContext.SCOPE_REQUEST) |
| session     | Scoped to an HTTP web session. Only used for web apps.      | @Scope(value = WebApplicationContext.SCOPE_SESSION) |
| application | Scoped to a web app ServletContext. Only used for web apps. |                                                     |
| websocket   | Scoped to a web socket. Only used for web apps.             |                                                     |

## Bean Life Cycle
1) Bean Life Cycle Flow 
2) Bean Instantiation 
3) Dependency Injection 
4) setBeanName() (optional)
5) setBeanFactory() (optional)
6) BeanPostProcessor — before initialization 
7) @PostConstruct / afterPropertiesSet()
8) Custom init() method 
9) BeanPostProcessor — after initialization 
10) Bean is Ready to Use 
11) Container Shutdown 
12) @PreDestroy or destroy()
13) Custom destroy() method
```
@Component
@Scope("singleton")
public class LifeCycleBean implements InitializingBean, DisposableBean, BeanNameAware {

    public LifeCycleBean() {
        System.out.println("1) Constructor: Bean Instantiated");
    }

    @Override
    public void setBeanName(String name) {
        System.out.println("2) setBeanName(): Bean name is " + name);
    }

    @PostConstruct
    public void postConstructMethod() {
        System.out.println("4) @PostConstruct: Bean initialization logic");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("5) afterPropertiesSet(): Property set completed");
    }

    public void customInit() {
        System.out.println("6) customInit(): custom init method executed");
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("8) destroy(): Bean cleanup code");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("7) @PreDestroy: before bean destruction");
    }

    public void customDestroy() {
        System.out.println("9) customDestroy(): custom destroy logic");
    }
}
```
### Enable Custom Init & Destroy Method
```
@Configuration 
public class AppConfig {

    @Bean(initMethod = "customInit", destroyMethod = "customDestroy")
    public LifeCycleBean lifeCycleBean() {
        return new LifeCycleBean();
    }
} 
```

## Java Bean Config
- Now we have a new Swim coach. 
### Development Process
- Create @Configuration class
- Define @Bean method to configure the bean
- Inject the bean into our controller
### Create a Java class and annotate as @Configuration
```
import org.springframework.context.annotation.Configuration;
@Configuration
public class SportConfig
    ....
}
```
### Step 2: Define @Bean method to configure the bean
```
import com. luv2code. springcoredemo. common. Coach; import com. luv2code.springcoredemo. common.SwimCoach; import org.springframework. context .annotation.Bean; import org.springframework.context.annotation.Configuration;
@Configuration
public class SportConfig {
@Bean
public Coach swimCoach () {
        return new SwimCoach ();
    }
}
```
### Inject the bean into our controller
### Use case for @Bean
- You may wonder ...
- Using the "new" keyword ... is that it???
- Why not just annotate the class with @Component???

### Use case for @Bean
- Make an existing third-party class available to Spring framework
- You may not have access to the source code of third-party class
- However, you would like to use the third-party class as a Spring bean

### Real-World Project Example
- Our project used Amazon Web Service (AWS) to store documents
- Amazon Simple Storage Service (Amazon S3)
- Amazon S3 is a cloud-based storage system
- can store PDF documents, images etc
- We wanted to use the AWS S3 client as a Spring bean in our app

### Real-World Project Example
- The AWS S3 client code is part of AWS SDK
- We can't modify the AWS SDK source code
- We can't just add @Component
- However, we can configure it as a Spring bean using @Bean

	
	
	