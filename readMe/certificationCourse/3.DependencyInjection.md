# Dependency Injection
# Dependency Injection
- Dependency Injection (DI) is a design pattern used in Spring to inject the dependencies (objects a class needs) instead of the class creating them itself.
- DI is a core concept of Spring and is a specific form of Inversion of Control (IoC).
###  üîπ Why DI?
- Without DI:
```
  public class Car {
  private Engine engine;
  public Car() {
    engine = new Engine(); // tightly coupled
    }
  }
```  
- Problems:
- Hard to test (Engine is hard-coded)
- Tightly coupled classes ‚Üí low flexibility
- Changing Engine type requires modifying Car
- **With DI:**
```
  public class Car {
  private Engine engine;

  // Engine is injected from outside
  public Car(Engine engine) {
    this.engine = engine;
    }
  }
```  
- Looser coupling
- Easier testing and maintenance
- Spring takes care of object creation and wiring
##   üîπ Types of Dependency Injection in Spring
Type	How It Works	Example
Constructor Injection	Dependencies are provided via constructor	@Autowired public Car(Engine engine) { ... }
Setter Injection	Dependencies are provided via setter methods	@Autowired public void setEngine(Engine engine) { ... }
Field Injection	Dependencies are injected directly into fields	@Autowired private Engine engine;

| Type                  | How It Works                                   | Example                                                 |
|-----------------------|------------------------------------------------|---------------------------------------------------------|
| Constructor Injection | Dependencies are provided via constructor      | @Autowired public Car(Engine engine) { ... }            |
| Setter Injection      | Dependencies are provided via setter methods   | @Autowired public void setEngine(Engine engine) { ... } |
| Field Injection       | Dependencies are injected directly into fields | @Autowired private Engine engine;                       |

### üîπ Step 1: Configure Spring Beans
- Using @Component (Recommended)
```
import org.springframework.stereotype.Component;
@Component
public class Engine {
    public void start() {
        System.out.println("Engine started!");
    }
}

@Component
public class Car {
private final Engine engine;

    // Constructor Injection
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving!");
    }
}
```
### üîπ Step 2: Enable Component Scanning
```
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class DiExampleApplication {
public static void main(String[] args) {
ApplicationContext context = SpringApplication.run(DiExampleApplication.class, args);

        Car car = context.getBean(Car.class);
        car.drive();
    }
}
```
- Output:
- Engine started!
- Car is driving!
- ‚úÖ Spring automatically creates Engine and Car beans and injects the dependency.
## üîπ Step 3: Advanced DI Concepts
### **1. Qualifier**
- If multiple beans of the same type exist:
```
@Component("v8")
   public class V8Engine implements Engine { ... }
```
```
@Component("v6")
public class V6Engine implements Engine { ... }
```
```
@Component
public class Car {
private final Engine engine;

    @Autowired
    public Car(@Qualifier("v8") Engine engine) {
        this.engine = engine;
    }
}
```
- @Qualifier tells Spring which bean to inject when multiple exist.
### 2. Primary Bean
```
   @Component
   @Primary
   public class DefaultEngine implements Engine { ... }
```   
- Marks one bean as default for injection when multiple beans exist.
### 3. Profile-Based DI
- Different beans for different environments:
```
@Component
   @Profile("dev")
   public class DevEngine implements Engine { ... }
```
```
@Component
@Profile("prod")
public class ProdEngine implements Engine { ... }
```
- Activate profile:
```
spring.profiles.active=dev
```
- Spring injects DevEngine in development, ProdEngine in production.
### 4. Custom Bean with @Bean
- You can define beans manually:
```
   @Configuration
   public class AppConfig {
   @Bean
   public Engine engine() {
   return new Engine(); // custom bean creation
   }
```
```
   @Bean
   public Car car(Engine engine) {
        return new Car(engine);
    }
   }
```   
- This gives more control over bean creation.
### 5. Optional Dependencies
```
@Autowired(required = false)
   private GPS gps;
```   
- Bean injection is optional, Spring won‚Äôt throw an error if GPS is missing.

## Scanning for Component Classes
- Spring will scan your Java classes for special annotations
- @Component, etc ...
- Automatically register the beans in the Spring container

## Annotation used in SpringBoot application class
- @SpringBootApplication is composed of the following annotations:

| Annotation               | Description                                                                       |
|--------------------------|-----------------------------------------------------------------------------------|
| @EnableAutoConfiguration | Enables Spring Boot's auto-configuration support                                  |
| @ComponentScan           | Enables component scanning of current package Also recursively scans sub-packages |
| @Configuration           | Able to register extra beans, with @Bean or import other configuration classes    |

## More on Component Scanning
-  By default, Spring Boot starts component scanning
-  From same package as your main Spring Boot application
-  Also scans sub-packages recursively
-  This implicitly defines a base search package
-  Allows you to leverage default component scanning*
- No need to explicitly reference the base package name
- **COMMON Pitfall - Different location**
- By Default, spring boot will not component scan these packages outside the core package
- Only Package of main springBoot application class and sub packages
### More on Component Scanning
- Default scanning is fine if everything is under com.mainspringboot.main

* But what about my other packages? Below packages are not inside main springboot application
- com. luv2code.util
- org.acme.cart
- edu.cmu.srs
- **Explicitly list base packages to scan**
```
package com. luv2code. springcoredemo;
...
@SpringBootApplication(
scanBasePackages=(
"com luv2code.springcoredemo",
"com.luv2code.util",
"org.acme.cart",
"edu.cmu.srs"})
public class SpringcoredemoApplication {
}
```
### Setter Injection in Spring Core
- Setter Injection is a type of Dependency Injection (DI) where Spring injects the dependency via a setter method instead of a constructor.
- The dependent object is passed to a setter method after the bean is created.
- Useful when dependencies are optional or when you want to change them later.
- **üîπ Example Using Spring Annotations**
```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Engine {
    public void start() {
        System.out.println("Engine started!");
    }
}
```
```
@Component
public class Car {
private Engine engine;

    // Setter Injection
    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving!");
    }
}
```
- **Main Application**
```
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class SetterInjectionExample {
public static void main(String[] args) {
ApplicationContext context = SpringApplication.run(SetterInjectionExample.class, args);

        Car car = context.getBean(Car.class);
        car.drive();
    }
}
```
- Output:
- Engine started!
- Car is driving!
- **Key Points**
- @Autowired on the setter method tells Spring to inject the dependency.
- Allows optional dependencies by setting required = false:
```
@Autowired(required = false)
public void setGPS(GPS gps) {
this.gps = gps;
}
```
- Dependencies are injected after bean construction.
- Setter injection can replace or update dependencies at runtime.
### Field Injection in Spring Core
- Field Injection is a type of Dependency Injection (DI) in Spring where the dependency is injected directly into a class field, bypassing constructors and setters.
- Spring injects the dependency directly into the member variable using the @Autowired annotation.
- Simplest form of DI, requires no setter or constructor.
- **Example Using Spring Annotations**
```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Engine {
public void start() {
System.out.println("Engine started!");
}
}
```
```
@Component
public class Car {

    // Field Injection
    @Autowired
    private Engine engine;

    public void drive() {
        engine.start();
        System.out.println("Car is driving!");
    }
}
```
- **Main Application**
```
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class FieldInjectionExample {
public static void main(String[] args) {
ApplicationContext context = SpringApplication.run(FieldInjectionExample.class, args);

        Car car = context.getBean(Car.class);
        car.drive();
    }
}
```
- Output:
- Engine started!
- Car is driving!
- **Key Points**
- @Autowired is applied directly on the field.
- No constructor or setter is required.
- Easy to implement, minimal boilerplate code.
- The dependency is injected after bean creation.
- Can be marked optional:
- @Autowired(required = false)
## When to Use Different Types of Dependency Injection

| Injection Type        | When to Use                                                                 | Pros                                                         | Cons                                                              |
|-----------------------|-----------------------------------------------------------------------------|--------------------------------------------------------------|-------------------------------------------------------------------|
| Constructor Injection | Mandatory dependencies that must be provided at object creation             | Ensures immutability, dependencies are final, easier to test | More boilerplate code if many dependencies                        |
| Setter Injection      | Optional dependencies or dependencies that may change after object creation | Flexible, allows optional dependencies                       | Dependencies can be changed, not immutable                        |
| Field Injection       | Quick and simple wiring for small projects or prototypes                    | Minimal boilerplate, very easy to use                        | Hard to unit test, tight coupling, not recommended for production |

## Qualifiers
- In Spring Boot, when multiple beans of the same type exist in the container, Spring gets confused about which one to inject.
- To resolve this ambiguity, we use @Qualifier, which explicitly tells Spring which specific bean to inject.
### üîπ Why do we need @Qualifier?
- When you have only one bean of a type, Spring autowires it automatically using @Autowired.
- But when multiple beans exist, Spring throws an NoUniqueBeanDefinitionException unless you specify which one to use.
### üßæ Basic Example Without @Qualifier
```
public interface PaymentService {
    void pay();
}

@Component
public class CreditCardPayment implements PaymentService {
    @Override
    public void pay() {
        System.out.println("Payment done using Credit Card");
    }
}

@Component
public class PaypalPayment implements PaymentService {
    @Override
    public void pay() {
        System.out.println("Payment done using PayPal");
    }
}
```
- Now if you autowire:
```
@Autowired
private PaymentService paymentService; // ‚ùå ERROR - multiple beans exist!
```
- Spring won‚Äôt know whether to inject CreditCardPayment or PaypalPayment.
- **‚úî Using @Qualifier to Resolve**
```
@Component
public class OrderService {
    @Autowired
    @Qualifier("paypalPayment")
    private PaymentService paymentService;
    
    public void processOrder() {
        paymentService.pay();
    }
}
```
- Here we explicitly tell Spring to inject the paypalPayment bean.
- Option 2: Naming Bean Explicitly
- You can also name beans manually:
```
@Bean("credit")
public PaymentService creditCardPayment() {
return new CreditCardPayment();
}

@Bean("paypal")
public PaymentService paypalPayment() {
return new PaypalPayment();
}
```
- Then inject:
```
@Autowired
@Qualifier("credit")
private PaymentService paymentService;
```
- üìå @Qualifier with Constructor Injection (Preferred)
```
@Component
public class OrderService {

    private final PaymentService paymentService;

    public OrderService(@Qualifier("creditCardPayment") PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    public void processOrder() {
        paymentService.pay();
    }
}
```
- Constructor injection + Qualifier = best practice ‚úî
### üî• Advanced Use: Multiple Qualifiers in Collection
```
@Component
public class Store {

    @Autowired
    @Qualifier("paypalPayment")
    private PaymentService paymentService;

    @Autowired
    private List<PaymentService> allPaymentServices; // Inject both beans!

    public void showPayments() {
        allPaymentServices.forEach(PaymentService::pay);
    }
}
```
- üëç Useful when you need all implementations simultaneously.

| Concept                | Meaning                                 |
|------------------------|-----------------------------------------|
| @Autowired             | Automatic bean injection                |
| Multiple beans = Error | Spring doesn‚Äôt know which one to inject |
| @Qualifier             | Specifies which bean to inject          |
| Best practice          | Use with constructor injection          |

	
	
	
	
	