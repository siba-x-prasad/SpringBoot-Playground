# Configuration, Pagination, Sorting

## Configuration
- What is Configuration?
- Configuration is how you externalize application settings so you donâ€™t hard-code values.
- Spring Boot supports:
  - application.properties 
  - application.yml
- **Environment variables**
- **Profiles (dev, test, prod)**
- ðŸ”¹ Example: application.yml
```
server:
port: 8081

app:
name: UserService
max-users: 100
```
- Access configuration using @Value
```
@Value("${app.name}")
private String appName;
```
- Best Practice: @ConfigurationProperties.
```
@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    private String name;
    private int maxUsers;
}
```
- Usage:
```
@Autowired
private AppProperties props;
```
- Type-safe
- Clean
- Recommended

- Profiles example
```
spring:
profiles:
active: dev

---
spring:
profiles: dev
server:
port: 8080
---
spring:
profiles: prod
server:
port: 80
```
## Pagination
- Why Pagination?
- Avoid loading huge datasets
- Improve performance
- Required for REST APIs
- Entity
```
@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;
}
```
- Repository (JpaRepository already supports pagination)
```
public interface UserRepository extends JpaRepository<User, Long> {
}
```
- Service with Pageable
```
public Page<User> getUsers(Pageable pageable) {
    return userRepository.findAll(pageable);
}
```
- Controller (Automatic binding)
```
@GetMapping("/users")
public Page<User> getUsers(
@RequestParam(defaultValue = "0") int page,
@RequestParam(defaultValue = "5") int size
) {
return userRepository.findAll(PageRequest.of(page, size));
}
```
-  Request Example
```GET /users?page=1&size=10```
- Response contains
```
{
"content": [...],
"totalElements": 50,
"totalPages": 5,
"size": 10,
"number": 1
}
```
## Sorting in Spring Boot
- Basic Sorting
```
Sort sort = Sort.by("name").ascending();
List<User> users = userRepository.findAll(sort);
```
- Pagination + Sorting together
```
PageRequest.of(page, size, Sort.by("name").descending());
```
- REST API Sorting (Automatic)
```
@GetMapping("/users")
public Page<User> getUsers(Pageable pageable) {
return userRepository.findAll(pageable);
}
```
- Call:
```
/users?page=0&size=5&sort=name,asc
Multiple fields:
/users?sort=name,asc&sort=id,desc
```
### Global Pagination Configuration
- application.yml
```
spring:
data:
web:
pageable:
default-page-size: 10
max-page-size: 100
```
- **Custom default sort**
```
spring:
data:
web:
sort:
sort-parameter: sort
```
## Best Practices
- Always paginate large datasets
- Never return List for large APIs
- Use Page<T> for REST APIs
- Expose sorting via query params
- Validate page size limits

## Common Mistakes
âŒ Using pagination in Controller only
âŒ Returning entity directly for public APIs
âŒ Allowing unlimited page size
âŒ Sorting by non-indexed columns

# Set Up values for Each environment
- Compound interest calculation 
- Interest rate is static per environment 
- Environments: dev / uat / prod 
- Using application.properties
### application.properties (COMMON CONFIG)
```
spring.profiles.active=dev

interest.years=5
interest.compounds-per-year=4
```
- These values are shared across all environments.
### Environment-Specific Properties
```
ðŸ“„ application-dev.properties
interest.rate=5.0
```
```
ðŸ“„ application-uat.properties
interest.rate=6.5
```
```
ðŸ“„ application-prod.properties
interest.rate=8.0
```
- Clean separation
- No code changes 
- Safe for production

3ï¸âƒ£ Configuration Properties Class (BEST PRACTICE)
@Component
@ConfigurationProperties(prefix = "interest")
public class InterestProperties {

    private double rate;
    private int years;
    private int compoundsPerYear;

    // getters & setters
}


ðŸ“Œ For Spring Boot 3+, make sure:

@EnableConfigurationProperties(InterestProperties.class)

4ï¸âƒ£ Compound Interest Service
@Service
public class InterestService {

    private final InterestProperties props;

    public InterestService(InterestProperties props) {
        this.props = props;
    }

    public double calculate(double principal) {
        double r = props.getRate() / 100;
        int n = props.getCompoundsPerYear();
        int t = props.getYears();

        return principal * Math.pow(1 + r / n, n * t);
    }
}

5ï¸âƒ£ REST Controller (Test Easily)
@RestController
@RequestMapping("/interest")
public class InterestController {

    private final InterestService service;

    public InterestController(InterestService service) {
        this.service = service;
    }

    @GetMapping("/calculate")
    public double calculate(@RequestParam double principal) {
        return service.calculate(principal);
    }
}

6ï¸âƒ£ How to Run & Test Each Environment
âœ… DEV (default)
mvn spring-boot:run

âœ… UAT
mvn spring-boot:run -Dspring-boot.run.profiles=uat

âœ… PROD
mvn spring-boot:run -Dspring-boot.run.profiles=prod

âœ… JAR (Most common in production)
java -jar app.jar --spring.profiles.active=prod

7ï¸âƒ£ Verify Which Environment is Active

Add a log:

@PostConstruct
public void logRate() {
System.out.println("Interest Rate = " + rate);
}


Or enable actuator:

/actuator/env

8ï¸âƒ£ Unit Testing Per Environment
@ActiveProfiles("uat")
@SpringBootTest
class InterestUatTest {

    @Autowired
    InterestService service;

    @Test
    void uatRateUsed() {
        double amount = service.calculate(10000);
        assertTrue(amount > 10000);
    }
}
# Calculate Compound Interest For Different Environment
- Project = myexperiment/compundinterest-with-different-environment
- **How to Run Each Environment**
- DEV (default)
```
mvn spring-boot:run
```
- **UAT**
```
mvn spring-boot:run -Dspring-boot.run.profiles=uat
```
- **PROD**
```
mvn spring-boot:run -Dspring-boot.run.profiles=prod
```
- **Using JAR**
```
java -jar target/compound-interest-demo.jar --spring.profiles.active=prod
```