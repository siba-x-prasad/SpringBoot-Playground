# Spring Core
# üîÑ Inversion of Control (IoC) in Spring
- Inversion of Control (IoC) is a core concept in Spring that removes the responsibility of creating objects from the program itself and gives it to the Spring Container.
- Instead of the class creating its own dependencies, Spring injects the required dependencies automatically.
##  üîπ Simple Explanation
- Imagine a Car class that needs an Engine:
- Without IoC (manual creation):
```
 public class Car {
  private Engine engine;

  public Car() {
  engine = new Engine(); // Car creates its own Engine
  }
  }
```  
- With IoC (Spring creates & injects dependencies):
```
public class Car {
  private Engine engine;

  public Car(Engine engine) { // Engine is injected
  this.engine = engine;
  }
  }
```  
- Spring creates the Engine object
- Spring injects it into Car
- Car doesn‚Äôt need to know how to create Engine
- This is called Dependency Injection, which is a form of IoC.
 ###  üîπ Benefits of IoC
- Loose Coupling	Classes depend on interfaces or injected objects, not concrete implementations
- Easier Testing	You can inject mock dependencies easily
- Reusability	Components are easier to reuse
- Maintainability	Spring manages object creation, wiring, and lifecycle
###  üîπ How Spring Implements IoC
- Bean Definition ‚Üí Define your class as a Spring Bean
```
@Component
  public class Engine { }
  Dependency Injection ‚Üí Spring injects the beans
  @Component
  public class Car {
  private Engine engine;
  @Autowired
  public Car(Engine engine) {
  this.engine = engine;
  }
  }
```  
- Spring Container ‚Üí Handles object creation, wiring, and lifecycle
###  üîπ Summary
- IoC = ‚ÄúLet Spring Control the Objects‚Äù
- Spring creates objects and injects dependencies automatically
- Forms the foundation of Spring Core
- Enables loose coupling, testability, and easy maintenance

# Dependency Injection
- Dependency Injection (DI) is a design pattern used in Spring to inject the dependencies (objects a class needs) instead of the class creating them itself.
- DI is a core concept of Spring and is a specific form of Inversion of Control (IoC).
###  üîπ Why DI?
- Without DI:
```
  public class Car {
  private Engine engine;
  public Car() {
    engine = new Engine(); // tightly coupled
    }
  }
```  
- Problems:
- Hard to test (Engine is hard-coded)
- Tightly coupled classes ‚Üí low flexibility
- Changing Engine type requires modifying Car
- **With DI:**
```
  public class Car {
  private Engine engine;

  // Engine is injected from outside
  public Car(Engine engine) {
    this.engine = engine;
    }
  }
```  
- Looser coupling
- Easier testing and maintenance
- Spring takes care of object creation and wiring
##   üîπ Types of Dependency Injection in Spring
  Type	How It Works	Example
  Constructor Injection	Dependencies are provided via constructor	@Autowired public Car(Engine engine) { ... }
  Setter Injection	Dependencies are provided via setter methods	@Autowired public void setEngine(Engine engine) { ... }
  Field Injection	Dependencies are injected directly into fields	@Autowired private Engine engine;

| Type                  | How It Works                                   | Example                                                 |
|-----------------------|------------------------------------------------|---------------------------------------------------------|
| Constructor Injection | Dependencies are provided via constructor      | @Autowired public Car(Engine engine) { ... }            |
| Setter Injection      | Dependencies are provided via setter methods   | @Autowired public void setEngine(Engine engine) { ... } |
| Field Injection       | Dependencies are injected directly into fields | @Autowired private Engine engine;                       |

### üîπ Step 1: Configure Spring Beans
- Using @Component (Recommended)
```
import org.springframework.stereotype.Component;
@Component
public class Engine {
    public void start() {
        System.out.println("Engine started!");
    }
}

@Component
public class Car {
private final Engine engine;

    // Constructor Injection
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving!");
    }
}
```
### üîπ Step 2: Enable Component Scanning
```
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class DiExampleApplication {
public static void main(String[] args) {
ApplicationContext context = SpringApplication.run(DiExampleApplication.class, args);

        Car car = context.getBean(Car.class);
        car.drive();
    }
}
```
- Output:
- Engine started!
- Car is driving!
- ‚úÖ Spring automatically creates Engine and Car beans and injects the dependency.
## üîπ Step 3: Advanced DI Concepts
### **1. Qualifier**
- If multiple beans of the same type exist:
```
@Component("v8")
   public class V8Engine implements Engine { ... }
```
```
@Component("v6")
public class V6Engine implements Engine { ... }
```
```
@Component
public class Car {
private final Engine engine;

    @Autowired
    public Car(@Qualifier("v8") Engine engine) {
        this.engine = engine;
    }
}
```
- @Qualifier tells Spring which bean to inject when multiple exist.
### 2. Primary Bean
```
   @Component
   @Primary
   public class DefaultEngine implements Engine { ... }
```   
- Marks one bean as default for injection when multiple beans exist.
### 3. Profile-Based DI
- Different beans for different environments:
```
@Component
   @Profile("dev")
   public class DevEngine implements Engine { ... }
```
```
@Component
@Profile("prod")
public class ProdEngine implements Engine { ... }
```
- Activate profile:
```
spring.profiles.active=dev
```
- Spring injects DevEngine in development, ProdEngine in production.
### 4. Custom Bean with @Bean
- You can define beans manually:
```
   @Configuration
   public class AppConfig {
   @Bean
   public Engine engine() {
   return new Engine(); // custom bean creation
   }
```
```
   @Bean
   public Car car(Engine engine) {
        return new Car(engine);
    }
   }
```   
- This gives more control over bean creation.
### 5. Optional Dependencies
```
@Autowired(required = false)
   private GPS gps;
```   
- Bean injection is optional, Spring won‚Äôt throw an error if GPS is missing.

## Scanning for Component Classes
- Spring will scan your Java classes for special annotations 
- @Component, etc ... 
- Automatically register the beans in the Spring container

## Annotation used in SpringBoot application class
- @SpringBootApplication is composed of the following annotations:

| Annotation               | Description                                                                       |
|--------------------------|-----------------------------------------------------------------------------------|
| @EnableAutoConfiguration | Enables Spring Boot's auto-configuration support                                  |
| @ComponentScan           | Enables component scanning of current package Also recursively scans sub-packages |
| @Configuration           | Able to register extra beans, with @Bean or import other configuration classes    |

## More on Component Scanning
-  By default, Spring Boot starts component scanning
-  From same package as your main Spring Boot application
-  Also scans sub-packages recursively
-  This implicitly defines a base search package
-  Allows you to leverage default component scanning*
- No need to explicitly reference the base package name
- **COMMON Pitfall - Different location**
- By Default, spring boot will not component scan these packages outside the core package
- Only Package of main springBoot application class and sub packages
### More on Component Scanning
- Default scanning is fine if everything is under com.mainspringboot.main

* But what about my other packages? Below packages are not inside main springboot application
- com. luv2code.util
- org.acme.cart
- edu.cmu.srs
- **Explicitly list base packages to scan**
```
package com. luv2code. springcoredemo;
...
@SpringBootApplication(
scanBasePackages=(
"com luv2code.springcoredemo",
"com.luv2code.util",
"org.acme.cart",
"edu.cmu.srs"})
public class SpringcoredemoApplication {
}
```
### Setter Injection in Spring Core
- Setter Injection is a type of Dependency Injection (DI) where Spring injects the dependency via a setter method instead of a constructor.
- The dependent object is passed to a setter method after the bean is created.
- Useful when dependencies are optional or when you want to change them later.
- **üîπ Example Using Spring Annotations**
```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Engine {
    public void start() {
        System.out.println("Engine started!");
    }
}
```
```
@Component
public class Car {
private Engine engine;

    // Setter Injection
    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving!");
    }
}
```
- **Main Application**
```
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class SetterInjectionExample {
public static void main(String[] args) {
ApplicationContext context = SpringApplication.run(SetterInjectionExample.class, args);

        Car car = context.getBean(Car.class);
        car.drive();
    }
}
```
- Output:
- Engine started!
- Car is driving!
- **Key Points**
- @Autowired on the setter method tells Spring to inject the dependency.
- Allows optional dependencies by setting required = false:
```
@Autowired(required = false)
public void setGPS(GPS gps) {
this.gps = gps;
}
```
- Dependencies are injected after bean construction.
- Setter injection can replace or update dependencies at runtime.
### Field Injection in Spring Core
- Field Injection is a type of Dependency Injection (DI) in Spring where the dependency is injected directly into a class field, bypassing constructors and setters.
- Spring injects the dependency directly into the member variable using the @Autowired annotation.
- Simplest form of DI, requires no setter or constructor.
- **Example Using Spring Annotations**
```
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Engine {
public void start() {
System.out.println("Engine started!");
}
}
```
```
@Component
public class Car {

    // Field Injection
    @Autowired
    private Engine engine;

    public void drive() {
        engine.start();
        System.out.println("Car is driving!");
    }
}
```
- **Main Application**
```
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class FieldInjectionExample {
public static void main(String[] args) {
ApplicationContext context = SpringApplication.run(FieldInjectionExample.class, args);

        Car car = context.getBean(Car.class);
        car.drive();
    }
}
```
- Output:
- Engine started!
- Car is driving!
- **Key Points**
- @Autowired is applied directly on the field.
- No constructor or setter is required.
- Easy to implement, minimal boilerplate code.
- The dependency is injected after bean creation.
- Can be marked optional:
- @Autowired(required = false)
## When to Use Different Types of Dependency Injection

| Injection Type        | When to Use                                                                 | Pros                                                         | Cons                                                              |
|-----------------------|-----------------------------------------------------------------------------|--------------------------------------------------------------|-------------------------------------------------------------------|
| Constructor Injection | Mandatory dependencies that must be provided at object creation             | Ensures immutability, dependencies are final, easier to test | More boilerplate code if many dependencies                        |
| Setter Injection      | Optional dependencies or dependencies that may change after object creation | Flexible, allows optional dependencies                       | Dependencies can be changed, not immutable                        |
| Field Injection       | Quick and simple wiring for small projects or prototypes                    | Minimal boilerplate, very easy to use                        | Hard to unit test, tight coupling, not recommended for production |

