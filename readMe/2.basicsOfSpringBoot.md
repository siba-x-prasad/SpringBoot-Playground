# Springboot
Documentation of SPRINGBOOT for beginners.
its provide a ready made web application project where all the configuration done itself and provide one ready project.Internally it maintain to provide Web server like **TOMCAT or GLASSFISH**. You no need to manually setup server for web application developed in springboot.
## Springboot Project Links
https://www.springboottutorial.com/spring-boot-projects-with-code-examples

## Here are the main concept of spring Boot
1. Dependency Injection.
2. Annotation Processor


## SPRING SUITE AND SPRING TOOLS
(IDE- Integrated Development Environment)
### IDE
1. NetBeans
2. Eclipse
3. Spring Tool Suite (STS)

You can download **Spring STS** from the link below  
**https://spring.io/guides/gs/sts/**

For Example if we want to buidl a laptop we need different parts from different companies. To assesmble them and make the laptop will take a lop of effort. For that there is a dependency between all the parts used to develop an laptop.
Same as laptop if we build a project there are different modules are needed and there must be a dependency between each other.    
**Loose Coupling** If One object is not completely dependent on another object. WE can use one object instead of another. This is known as Loose Coupling. LEts for example, while assembling HP laptop, we can use Hard disk of any company(Samsung, HP,ASUS). So this is known as Loose Coupling.

**Tight Coupling** When a object or classes is totaly dependent on another class and we cant use other class/object instead of the class. THis is known as Tight Coupling. FOr Apple Laptop only Apple harddisk is required to assemble it. So this is tight coupling.

## Request Annotations
## **@Controller**  
- This annotation is used to make a class as web controller, which can handle client requests and send a response back to the client. 
- This is a class level annotation, which is put on top of your controller class. 
- Similar to @Service and @Repository it is also a stereotype annotation. 
- If you are wondering what is the difference between them then you can also see this article to learn more about their differences.
- Here is an example of @Controller annotation in Spring MVC:

```
@Controller
public class HelloController{
// handler methods
}
``` 
## **@RequestMapping**  
- The Controller class contains several handler methods to handle different HTTP request but how does Spring map a particular request to a particular handler method? Well, that's done with the help of the @RequestMapping annotation. It's a method level annotation which is specified over a handler method.

```
@Controller 
public class HelloControler{ 
  @RequestMapping("/") 
    public String hello(){ 
      return "Hello Spring MVC"; 
    }  
}
```   

## **@RequestParam**  
- This is another useful Spring MVC annotation which is used to bind HTTP parameters into method arguments of handler methods. 
- For example, if you send query parameters along with URLlikie for paging or just to supply some key data then you can get them as method arguments in your handler methods.
- Here is an example of @RequestParam annotation in Spring MVC from my earlier article about the difference between RequestParam and PathVariable annotation:

```
@RequestMapping("/book") 
public String showBookDetails( @RequestParam("ISBN") String ISBN, Model model){ 
model.addAttribute("ISBN", ISBN); return "bookDetails"; 
}
```   
- If you access your web application which provides book details with a query parameter like below:

**http://localhost:8080/book?ISBN=900848893**.   
## **@PathVariable**  
- This is another annotation which is used to retrieve data from the URL. 
- Unlike @RequestParam annotation which is used to extract query parameters, this annotation enables the controller to handle a request for parameterized URLs like URLs that have variable input as part of their path like:

**http://localhost:8080/books/900083838**.  
- If you want to retrieve the ISBN number "900083838" from the URL as method argument then you can use @PathVariable annotation in Spring MVC as shown below:

```
@RequestMapping(value="/books/{ISBN}",method= RequestMethod.GET)
public String showBookDetails(@PathVariable("ISBN") String id,Model model){
   model.addAttribute("ISBN", id);
   return "bookDetails";
} 
```  
## **@RequestBody**  
- This annotation can convert inbound HTTP data into Java objects passed into the controller's handler method. 
- Just as @ResponseBody tells the Spring MVC to use a message converter when sending a response to the client, the @RequestBody annotations tell the Spring to find a suitable message converter to convert a resource representation coming from a client into an object.
- Here is an example:
``` 
@RequestMapping(method=RequestMethod.POST, consumers= "application/json")
public @ResponseBody Course saveCourse(@RequestBody Course aCourse){
   return courseRepository.save(aCourse);
}
```  
## **@ResponseBody**  
- The @ResponseBody annotation is one of the most useful annotations for developing RESTful web service using Spring MVC. 
- This annotation is used to transform a Java object returned from he a controller to a resource representation requested by a REST client. 
- It can completely bypass the view resolution part.
- Here is an example of @ResponseBody annotation in Spring MVC:
```  
@RequestMapping(method=RequestMethod.POST,consumers= "application/json")
public @ResponseBody Course saveCourse(@RequestBody Course aCourse){
  return courseRepository.save(aCourse);
}
```   
## **@RestController**  
- This is convenience annotation for developing RESTful web service with Spring MVC framework. 
- The @RestController is a combination of @Controller and @ResponseBody, which was introduced in the Spring 3.4 version.
- When you annotate a controller class with @RestController it does two purposes, first, it says that the controller class is handling a request for REST APIs and second you don't need to annotate each method with the @ResposneBody annotation to signal that the response will be converted into a Resource using various HttpMessageConverers.
- Here is an example of @RestController annotation in Spring MVC:
```  
@RestController
class HelloControler{

@RequestMapping("/")
public String hello(){
  return "Hello Spring Booot";
}
}
```  
## **@SprinbBootApplication**.  
- This is a relatively new annotation but very useful if you are using Spring Boot for creating Java web application with Spring. This single annotation combines three annotations like @Configuration, @EnableAutoConfiguration, and @ComponentScan. If you use Spring Boot, then you can run your application without deploying into a web server, as it comes with an embedded Tomcat server.
- When you annotated your Main class with @SpringBootApplication then it enables Java-based configuration as well as component scanning and auto-configuration feature of Spring Boot, which can magically set up things for you by just dropping the required JAR into classpath.
- here is an example of using @SpringBootApplicaiton annotation in Spring:
```    
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication 
// same as @Configuration @EnableAutoConfiguration @ComponentScan
public class SpringBootApp{

 public static void main(String[] args) {
  SpringApplication.run(SpringBootApp.class, args);
 }
}
```  
- **FOR MORE DETAILS https://www.java67.com/2019/04/top-10-spring-mvc-and-rest-annotations-examples-java.html#ixzz6GOE3Vp2B**

## **Model, ModelMap, ModelAndView**  
- Model, ModelMap, and ModelAndView are used to define a model in a Spring MVC application. 
- Model defines a holder for model attributes and is primarily designed for adding attributes to the model. 
- ModelMap is an extension of Model with the ability to store attributes in a map and chain method calls. 
- ModelAndView is a holder for a model and a view; it allows to return both model and view in one return value.

## **Model**.
- Let's start with the most basic concept here – the Model.
- Simply put, the model can supply attributes used for rendering views.
- To provide a view with usable data, we simply add this data to its Model object. Additionally, maps with attributes can be merged with Model instances:
```  
@GetMapping("/showViewPage")
public String passParametersWithModel(Model model) {
    Map<String, String> map = new HashMap<>();
    map.put("spring", "mvc");
    model.addAttribute("message", "Baeldung");
    model.mergeAttributes(map);
    return "viewPage";
}  
```  
## **ModelMap**  
- Just like the Model interface above, ModelMap is also used to pass values to render a view.
- The advantage of ModelMap is it gives us the ability to pass a collection of values and treat these values as if they were within a Map:
```
@GetMapping("/printViewPage")
public String passParametersWithModelMap(ModelMap map) {
    map.addAttribute("welcomeMessage", "welcome");
    map.addAttribute("message", "Baeldung");
    return "viewPage";
} 
```  
## **ModelAndView**  
- The final interface to pass values to a view is the ModelAndView.
- This interface allows us to pass all the information required by Spring MVC in one return:
```
@GetMapping("/goToViewPage")
public ModelAndView passParametersWithModelAndView() {
    ModelAndView modelAndView = new ModelAndView("viewPage");
    modelAndView.addObject("message", "Baeldung");
    return modelAndView;
}
```  
## **The View**    
- All the data, we place within these models, is used by a view – in general, a templated view to render the web page.
- If we have a Thymeleaf template file targeted by our controller's methods as their view. 
- A parameter passed through the model will be accessible from within the thymeleaf HTML code:
```
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Title</title>
</head>
<body>
    <div>Web Application. Passed parameter : th:text="${message}"</div>
</body>
</html>
```  
- **In spring object's are provided by another dependency container. In spring all the dependency objects are provided by Soring Container. THis is nothing but Dependency Injection.**

## **SpringBoot terms**  
**1. @Component** -
**2. @AutoWired**-
**3. @Controller**-

**@Bean -** indicates that a method produces a bean to be managed by Spring.  
**@Service -** indicates that an annotated class is a service class.  
**@Repository -** indicates that an annotated class is a repository, which is an abstraction of data access and storage.  
**@Configuration -** indicates that a class is a configuration class that may contain bean definitions.  
**@Controller -** marks the class as web controller, capable of handling the requests.  
**@RequestMapping -** maps HTTP request with a path to a controller method.  
**@Autowired -** marks a constructor, field, or setter method to be autowired by Spring dependency injection.  
**@SpringBootApplication -** enables Spring Boot autoconfiguration and component scanning.  
**@Component** is a generic stereotype for a Spring managed component. It turns the class into a Spring bean at the auto-scan time. Classes decorated with this annotation are considered as candidates for auto-detection when using annotation-based   configuration and classpath scanning.   
**@Repository, @Service, and @Controller** are specializations of @Component for more specific use cases.
**@Target(ElementType.TYPE)**   
**@Retention(RetentionPolicy.RUNTIME)**
**@Documented**  
**@Inherited**   
**@Configuration**   
**@EnableAutoConfiguration**   
**@ComponentScan**

There are also Hibernate **@Entity, @Table, @Id, and @GeneratedValue** annotations in the example.  


# Springboot - Dependency Injection, Annotation Processor
## Dependency Injection — concept & how it works
- Dependency Injection (DI) is a design pattern where an object (the dependent) receives its dependencies from an external source (the injector / container) instead of creating them itself. This implements Inversion of Control (IoC) — the control over creating/configuring dependencies is inverted from the class to a container.
- Benefits
   - Better testability (swap mocks easily)
   - Loose coupling (classes depend on abstractions)
   - Clearer responsibilities (classes don't instantiate their dependencies)
   - Easier configuration & lifecycle management
- Common forms of injection
   - Constructor injection (recommended) — dependencies provided through constructor parameters.
   - Setter injection — dependencies set through setter methods.
   - Field (reflection) injection — dependencies injected directly into fields (less recommended).
- How a DI container generally works (runtime)
   - You declare "beans" (classes/components) and how they relate (via configuration, annotations).
   - The container builds a dependency graph, resolves each bean's dependencies, and instantiates them (honoring scopes like singleton/prototype).
   - The container injects resolved dependencies into constructors/fields/setters.
   - The container manages lifecycle callbacks (initialization, destruction). 
   - Runtime DI example: Spring (most familiar to Java devs)
- Why Spring?
   - Runtime, reflection-based container.
   - Rich life-cycle, AOP, configuration. 
   - Uses annotations like @Component, @Service, @Repository, @Controller, and injection via constructors or @Autowired.
 - Example
   - BookService.java
   - package com.example.demo.service;
```
import org.springframework.stereotype.Service;
import java.util.*;

@Service
public class BookService {
private final Map<Long, String> repo = new HashMap<>();

    public BookService() {
        repo.put(1L, "The Hobbit");
        repo.put(2L, "Effective Java");
    }

    public String findBook(long id) {
        return repo.get(id);
    }
}
BookController.java
package com.example.demo.controller;

import com.example.demo.service.BookService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/books")
public class BookController {

    // Constructor injection (recommended)
    private final BookService bookService;

    public BookController(BookService bookService) {
        this.bookService = bookService;
    }

    @GetMapping("/{id}")
    public String getBook(@PathVariable long id) {
        String book = bookService.findBook(id);
        if (book == null) throw new ResourceNotFoundException("Book not found");
        return book;
    }
}
```
## What happens at runtime:
- At application startup, Spring scans packages, finds @Service and @RestController.
- It creates BookService bean and BookController bean.
- Spring sees BookController needs BookService and injects the same instance into its constructor.
- When a request arrives, Spring uses that already-created bean.
## Notes / Best practice
- Prefer constructor injection — it makes dependencies explicit and supports immutability.
- Avoid field injection for production code (harder to test).
- Spring traditionally used reflection; recent Spring AOT (ahead-of-time) can precompute wiring for faster startup, but typical Spring is runtime DI. 
## Compile-time DI example: Dagger (uses annotation processing)
   - Compile-time DI frameworks (Dagger, Guice with AssistedInject variants, etc.) generate code at compile time (via annotation processors). No or minimal reflection at runtime → better performance and earlier error detection.
   - Dagger minimal example
```
UserRepository.java
   import javax.inject.Inject;
   import javax.inject.Singleton;

@Singleton
public class UserRepository {
@Inject
public UserRepository() { }
}
UserService.java
import javax.inject.Inject;

public class UserService {
private final UserRepository repo;

    @Inject
    public UserService(UserRepository repo) {
        this.repo = repo;
    }
}
AppModule.java (optional if you need custom providers)
import dagger.Module;
import dagger.Provides;
import javax.inject.Singleton;

@Module
public class AppModule {
@Provides @Singleton
UserRepository provideRepo() {
return new UserRepository();
}
}
AppComponent.java
import dagger.Component;
import javax.inject.Singleton;

@Singleton
@Component(modules = {AppModule.class})
public interface AppComponent {
UserService userService();
}
Usage:
public class Main {
public static void main(String[] args) {
AppComponent component = DaggerAppComponent.create(); // generated class
UserService us = component.userService();
// use userService...
}
}
```
## What happens at compile time:
- Dagger's annotation processor scans @Inject, @Module, @Component.
- It generates Java code implementing AppComponent (e.g., DaggerAppComponent) that knows exactly how to instantiate objects and inject dependencies — no runtime reflection.
- The generated code is compiled together with your code.
## Pros of compile-time DI
- Fast startup, no reflection-based scanning.
- Compile-time errors when wiring is wrong.
- Smaller runtime overhead.
## Cons
- More rigid configuration in some cases.
- Annotation processors add to compile time.
## Annotation processors — concept & how they work
- Annotation Processing is a Java compile-time facility that lets you read source annotations and generate additional source files or other resources before final compilation finishes. It's part of the Java Compiler API (javax.annotation.processing + javax.lang.model.*).
- Key ideas
  - An annotation processor runs during compilation (javac, Maven, Gradle). 
  - It receives elements annotated with particular annotations (classes, methods, fields).
  - It can generate new .java source files (via Filer) which are then compiled in subsequent compilation rounds.
  - Typical use-cases: code generation (Dagger, MapStruct, Immutables), compile-time validation (checking proper annotation usage), and metaprogramming (Lombok modifies AST via non-standard APIs).
- Lifecycle during compilation
  - Rounds: Processors can run in multiple rounds. Generated source files from round N are compiled and become available to the processors in round N+1.
  - The processor's process() method is called with a RoundEnvironment that contains elements annotated in that round.
  - APIs you use
  - AbstractProcessor — base class to implement.
  - processingEnv gives you Filer (to create files), Messager (log errors/warnings), Elements and Types utilities.
  - Filer#createSourceFile(...) — create a .java file.
  - RoundEnvironment#getElementsAnnotatedWith(...) — find elements to process. 
  - 
## Minimal annotation processor example
   Goal: create a tiny @AutoLogger annotation. When you annotate a class @AutoLogger, the processor will generate a helper logger class MyClass_Logger with a log() stub.
   This is a simplified example for demonstration (real processors handle more edge cases).
   Step A — The annotation
```
   package com.example.processor;

import java.lang.annotation.*;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface AutoLogger {
}
Step B — The processor
package com.example.processor;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.tools.JavaFileObject;
import java.io.Writer;
import java.util.Set;

@SupportedAnnotationTypes("com.example.processor.AutoLogger")
@SupportedSourceVersion(SourceVersion.RELEASE_11)
public class AutoLoggerProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(AutoLogger.class)) {
            if (element.getKind() != ElementKind.CLASS) continue;
            TypeElement typeElement = (TypeElement) element;
            String pkg = processingEnv.getElementUtils().getPackageOf(typeElement).getQualifiedName().toString();
            String className = typeElement.getSimpleName().toString();
            String generatedClass = className + "_Logger";
            try {
                JavaFileObject jfo = processingEnv.getFiler().createSourceFile(pkg + "." + generatedClass);
                try (Writer w = jfo.openWriter()) {
                    w.write("package " + pkg + ";\n\n");
                    w.write("public class " + generatedClass + " {\n");
                    w.write("    public static void log(String msg) {\n");
                    w.write("        System.out.println(\"[" + className + "] \" + msg);\n");
                    w.write("    }\n");
                    w.write("}\n");
                }
            } catch (Exception e) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Failed to write: " + e.getMessage());
            }
        }
        return true; // claim annotations
    }
}
```
- Step C — Register the processor
- Create resource file META-INF/services/javax.annotation.processing.Processor containing:
```
com.example.processor.AutoLoggerProcessor
(Alternatively use Google's @AutoService to generate that file.)
Step D — Usage in user code
package com.example.app;

import com.example.processor.AutoLogger;

@AutoLogger
public class MyService {
public void doWork() {
MyService_Logger.log("working");
}
}
After compilation, MyService_Logger is generated and available to call.
Build setup (Gradle snippet)
dependencies {
// The processor needs to be on the annotationProcessor classpath
annotationProcessor project(':my-processor') // or a library
}
```
## What the processor did:
- Found the annotated class MyService, generated MyService_Logger.java.
- The compiler compiles the generated file during the next round, so user code can reference it.
6) How DI and annotation processors interact
   Dagger: DI framework that is an annotation processor — it reads @Inject, @Module, @Component and generates concrete factory/component classes at compile time that wire everything.
   MapStruct: annotation processor that generates mapper implementations.
   Lombok: modifies AST during compilation to avoid writing boilerplate (not strictly via Filer, but via nonstandard compiler hooks).
   Spring: traditionally runtime-reflection based, but recently supports AOT generating some artifacts (Spring Native / AOT) which uses build-time processing. Spring does not primarily rely on javac annotation processors for DI.
   So: annotation processors can be used to implement DI (Dagger) or augment DI by generating code the DI container will use.
7) Pros/Cons — runtime DI (Spring) vs compile-time DI (Dagger / processors)
   Runtime DI (Spring)
   Very flexible configuration (profiles, runtime conditions).
   Mature ecosystem and features (AOP, transactions, auto-configuration).
   − Performance cost of reflection and classpath scanning (start-up overhead).
   − Wiring errors may appear at runtime (unless you write tests).
   Compile-time DI (Dagger)
   No reflection -> faster startup & lower runtime overhead.
   Wiring errors detected at compile time.
   − More boilerplate/setup; less flexible at runtime (but you can still pass modules).
   Annotation processors (in general)
   Generate code, enforce rules, improve performance.
   − Adds compile-time complexity; must manage incremental compilation and classpath.
8) Best practices & recommendations
   For enterprise apps needing flexibility and features, Spring is great — use constructor injection and component scanning.
   For mobile/embedded/latency-sensitive situations, prefer compile-time DI (Dagger).
   Use annotation processors to generate repetitive or error-prone code (mappers, factories, builders).
   Keep processors simple and produce clear errors via Messager so developers see problems early.
   Test generated code paths (unit tests for processors are possible using compile-testing tools).
9) Quick cheat-sheet of annotations (Java / Spring / Dagger)
   @Component, @Service, @Repository, @Controller — Spring-managed beans.
   @Autowired — Spring injection (constructor injection preferred; since Spring 4.3 if a class has single constructor you can omit @Autowired).
   @Inject — JSR-330 standard injection annotation (used by Dagger).
   @Module, @Provides, @Component — Dagger config.
   @SupportedAnnotationTypes, @SupportedSourceVersion, AbstractProcessor — annotation processor basics.
   Filer, Messager, Elements, Types, RoundEnvironment — processing utilities.


  
  
